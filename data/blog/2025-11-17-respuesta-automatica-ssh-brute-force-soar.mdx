---
title: 'De alertas a acci√≥n: respuesta autom√°tica a SSH brute force con SOAR (Shuffle + Wazuh)'
date: '2025-11-17T00:00:00'
lastmod: '2025-11-17T00:00:00'
summary: 'De la alerta en Wazuh al bloqueo autom√°tico en iptables con Shuffle SOAR en menos de 15 s. Arquitectura, c√≥digo completo, pruebas y troubleshooting real.'
tags:
  [
    'soar',
    'shuffle',
    'wazuh',
    'automatizacion',
    'incident-response',
    'ssh-security',
    'python',
    'iptables',
  ]
draft: false
authors: ['default']
images:
  [
    '/images/blog/2025-11-17-respuesta-automatica-ssh-brute-force-soar/21_shuffle_execution_success.png',
  ]
project: 'wazuh-soar'
---

> **Resumen ejecutivo:** En este tutorial construyo una respuesta autom√°tica a ataques SSH brute force que va desde la alerta en **Wazuh** hasta el **bloqueo de IP con iptables** orquestado por **Shuffle SOAR**. El objetivo es que, en **menos de 15 segundos**, el sistema pase de _detectar_ a _mitigar_ sin intervenci√≥n humana. Comparto arquitectura, c√≥digo completo, decisiones de dise√±o, pruebas end‚Äëto‚Äëend y el troubleshooting real que me encontr√©.

## 0. Contexto y alcance

Este post asume que ya ten√©s un laboratorio con **Wazuh** y **Shuffle** funcionando. Si te perdiste la primera parte, [ac√° est√° el post de integraci√≥n Wazuh-Shuffle](https://cobalto-sec.tech/blog/2025-11-12-de-cero-a-soar-integrando-wazuh-con-shuffle) donde cubrimos el setup base.

**El caso de uso:** SSH brute force contra un host Linux. Cuando se detectan m√∫ltiples intentos fallidos, Wazuh env√≠a un **webhook** hacia Shuffle. Shuffle procesa el evento, valida que sea un ataque real y, si corresponde, invoca un **API local (Flask)** que ejecuta `iptables` para bloquear la IP atacante.

**Stack t√©cnico:**

- **SIEM:** Wazuh 4.9.2 (single-node en Docker)
- **SOAR:** Shuffle (OpenSearch + Backend + Frontend)
- **Automation:** Python 3.10 + Flask
- **Firewall:** iptables + systemd service
- **Integration:** Webhooks + JSON

> **Tip:** Si es tu primera vez con Shuffle, empez√° con un _hello webhook_ simple (un flujo que solo recibe y registra el payload). Valid√°s red, puertos y formato antes de meter l√≥gica compleja.

---

## 1. El coraz√≥n del sistema: Firewall Blocker API

Antes de que Shuffle pueda bloquear IPs, necesitamos **algo que efectivamente las bloquee** en el host objetivo.

### 1.1 ¬øPor qu√© un API?

- Shuffle no puede (ni debe) ejecutar comandos arbitrarios en tus VMs
- Un **API** nos da un punto de control con _inputs_ validados y capacidad de auditor√≠a
- Pod√©s evolucionar a otros motores (nftables, firewalld) sin cambiar el flujo SOAR

```
Shuffle ‚Üí HTTP POST ‚Üí API ‚Üí iptables ‚Üí IP bloqueada
```

### 1.2 El c√≥digo completo (Flask + iptables)

**Ubicaci√≥n:** `/home/wazuh/security-automation/firewall_blocker.py`

```python
from flask import Flask, request, jsonify
import subprocess
import re
import logging

app = Flask(__name__)

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def is_valid_ip(ip):
    """Validar formato IPv4"""
    pattern = r'^(\d{1,3}\.){3}\d{1,3}$'
    if not re.match(pattern, ip):
        return False
    octets = ip.split('.')
    return all(0 <= int(octet) <= 255 for octet in octets)

def execute_iptables(action, ip):
    """Ejecutar comando iptables de forma segura"""
    try:
        if action == "block":
            cmd = ["sudo", "/usr/sbin/iptables", "-I", "INPUT", "-s", ip, "-j", "DROP"]
        elif action == "unblock":
            cmd = ["sudo", "/usr/sbin/iptables", "-D", "INPUT", "-s", ip, "-j", "DROP"]
        else:
            return False, "Invalid action"

        result = subprocess.run(cmd, capture_output=True, text=True, timeout=5)

        if result.returncode == 0:
            logger.info(f"{action.upper()} successful for IP: {ip}")
            return True, f"IP {ip} {action}ed successfully"
        else:
            logger.error(f"iptables error: {result.stderr}")
            return False, result.stderr

    except subprocess.TimeoutExpired:
        return False, "Command timeout"
    except Exception as e:
        logger.error(f"Exception: {str(e)}")
        return False, str(e)

@app.route('/health', methods=['GET'])
def health():
    """Health check endpoint"""
    return jsonify({
        "service": "firewall-blocker",
        "status": "healthy"
    }), 200

@app.route('/block', methods=['POST'])
def block_ip():
    """Bloquear una IP"""
    data = request.get_json()

    if not data or 'ip' not in data:
        return jsonify({
            "success": False,
            "message": "Missing 'ip' field in request body"
        }), 400

    ip = data['ip']

    if not is_valid_ip(ip):
        return jsonify({
            "success": False,
            "message": f"Invalid IP address format: {ip}"
        }), 400

    # Evitar bloquear localhost
    if ip in ['127.0.0.1', '::1', 'localhost']:
        return jsonify({
            "success": False,
            "message": "Cannot block localhost"
        }), 400

    success, message = execute_iptables("block", ip)

    if success:
        return jsonify({
            "action": "blocked",
            "ip": ip,
            "message": message,
            "success": True
        }), 200
    else:
        return jsonify({
            "action": "blocked",
            "ip": ip,
            "message": message,
            "success": False
        }), 500

@app.route('/unblock', methods=['POST'])
def unblock_ip():
    """Desbloquear una IP"""
    data = request.get_json()

    if not data or 'ip' not in data:
        return jsonify({
            "success": False,
            "message": "Missing 'ip' field in request body"
        }), 400

    ip = data['ip']

    if not is_valid_ip(ip):
        return jsonify({
            "success": False,
            "message": f"Invalid IP address format: {ip}"
        }), 400

    success, message = execute_iptables("unblock", ip)

    if success:
        return jsonify({
            "action": "unblocked",
            "ip": ip,
            "message": message,
            "success": True
        }), 200
    else:
        return jsonify({
            "action": "unblocked",
            "ip": ip,
            "message": message,
            "success": False
        }), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5555, debug=False)
```

**Caracter√≠sticas clave:**

- ‚úÖ Validaci√≥n de formato IPv4
- ‚úÖ Protecci√≥n contra bloqueo de localhost
- ‚úÖ Logging de todas las acciones
- ‚úÖ Endpoints `/health`, `/block`, `/unblock`
- ‚úÖ Timeouts para evitar comandos colgados

### 1.3 Configuraci√≥n del host

**Sudoers para iptables sin password:**

```bash
echo "wazuh ALL=(ALL) NOPASSWD: /usr/sbin/iptables" | sudo tee /etc/sudoers.d/wazuh-iptables
sudo chmod 0440 /etc/sudoers.d/wazuh-iptables
```

> **Warning:** Valid√° la ruta de `iptables` en tu distro (`which iptables`). Si cambia, actualiz√° la entrada en `sudoers`.

**Servicio systemd:**

```ini
# /etc/systemd/system/firewall_blocker.service
[Unit]
Description=Firewall Blocker API (Flask)
After=network.target

[Service]
User=wazuh
Group=wazuh
WorkingDirectory=/home/wazuh/security-automation
Environment="PYTHONUNBUFFERED=1"
ExecStart=/usr/bin/python3 /home/wazuh/security-automation/firewall_blocker.py
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
```

**Habilitar y arrancar el servicio:**

```bash
sudo systemctl daemon-reload
sudo systemctl enable firewall_blocker
sudo systemctl start firewall_blocker
sudo systemctl status firewall_blocker
```

### 1.4 Testing del API

![Tests del Firewall Blocker API](/images/blog/2025-11-17-respuesta-automatica-ssh-brute-force-soar/19_firewall_api_test.png)
_Caption: Health check, bloqueo y desbloqueo exitosos_

```bash
# Test b√°sico
curl http://localhost:5555/health

# Bloquear IP de prueba
curl -X POST http://localhost:5555/block \
  -H "Content-Type: application/json" \
  -d '{"ip": "1.2.3.4"}'

# Verificar en iptables
sudo iptables -L INPUT -n | grep 1.2.3.4

# Desbloquear
curl -X POST http://localhost:5555/unblock \
  -H "Content-Type: application/json" \
  -d '{"ip": "1.2.3.4"}'
```

**Resultado esperado:** IP bloqueada y desbloqueada en segundos.

> **Lesson Learned:** Aisl√° el componente de bloqueo detr√°s de un API m√≠nimo. Te permite testearlo sin Shuffle ni Wazuh, y descubrir problemas de permisos/paths desde el minuto cero.

---

## 2. Construyendo el workflow de respuesta en Shuffle

### 2.1 Arquitectura simplificada del flujo

![Workflow final simplificado](/images/blog/2025-11-17-respuesta-automatica-ssh-brute-force-soar/24_shuffle_workflow_diagram.png)
_Caption: Workflow de 3 nodos - simple y robusto_

```
[Webhook Wazuh]
    ‚Üì
[Process & Block] ‚Üê Parsea + verifica + bloquea
    ‚Üì
[Log Result] ‚Üê Registra la acci√≥n
```

**¬øPor qu√© tan simple?** Menos nodos = menos puntos de fallo, menos estado a depurar y respuesta m√°s r√°pida.

### 2.2 El nodo cr√≠tico: `Process_and_Block`

**C√≥digo completo del nodo Execute Python:**

```python
import json
import re
import requests

rule_id = "$exec.rule_id"
text = "$exec.text"
title = "$exec.title"

src_ip = "unknown"

# Buscar IP en formato "from X.X.X.X"
from_match = re.search(r'from\s+(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})', text)
if from_match:
    src_ip = from_match.group(1)

# Buscar IP en formato "rhost=X.X.X.X"
if src_ip == "unknown":
    rhost_match = re.search(r'rhost=(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})', text)
    if rhost_match:
        src_ip = rhost_match.group(1)

# Buscar cualquier IP en el texto
if src_ip == "unknown":
    ip_pattern = r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'
    ip_matches = re.findall(ip_pattern, text)
    if ip_matches:
        src_ip = ip_matches[0]

# Lista de rule_ids de SSH brute force
ssh_rules = ["100001", "5710", "5712", "2502", "5503", "5551"]

result = {
    "rule_id": rule_id,
    "src_ip": src_ip,
    "action_taken": "none",
    "message": ""
}

# IPs a ignorar (localhost, etc.)
skip_ips = ["127.0.0.1", "::1", "localhost"]

if rule_id in ssh_rules and src_ip not in skip_ips and src_ip != "unknown":
    try:
        resp = requests.post(
            "http://192.168.0.121:5555/block",
            json={"ip": src_ip},
            timeout=5
        )

        if resp.status_code == 200:
            result["action_taken"] = "blocked"
            result["message"] = "Blocked " + src_ip
        else:
            result["action_taken"] = "error"
            result["message"] = "HTTP " + str(resp.status_code)

    except Exception as e:
        result["action_taken"] = "error"
        result["message"] = str(e)[:100]
else:
    result["action_taken"] = "skipped"
    result["message"] = "Rule " + rule_id + " IP " + src_ip

print(json.dumps(result))
```

**Lo que hace:**

1. Extrae `rule_id` del payload Wazuh
2. Busca la IP atacante en 3 formatos diferentes (regex flexible)
3. Verifica si es un rule_id de SSH brute force
4. Si corresponde, llama al API de bloqueo
5. Registra el resultado

### 2.3 La batalla contra los booleanos (troubleshooting real)

**El problema:** Shuffle inyecta JSON con `true`/`false` (lowercase) que Python no interpreta correctamente.

**La soluci√≥n:** Acceder a campos individuales en vez de evaluar el JSON completo.

```python
# ‚ùå NO FUNCIONA
data = $exec  # Inserta JSON crudo con true/false

# ‚úÖ FUNCIONA
rule_id = "$exec.rule_id"   # Acceso directo al campo
src_ip  = "$exec.src_ip"    # Shuffle reemplaza antes de ejecutar Python
```

> **Lesson Learned:** Me cost√≥ ~3 horas debuggear esto. Cuando veas `name 'true' is not defined`, no es Python rompi√©ndose - es Shuffle insertando JSON que Python no puede evaluar directamente.

### 2.4 Testing del workflow

![Ejecuci√≥n exitosa en Shuffle](/images/blog/2025-11-17-respuesta-automatica-ssh-brute-force-soar/21_shuffle_execution_success.png)
_Caption: IP extra√≠da correctamente, acci√≥n tomada_

**Resultado t√≠pico esperado:**

```json
{
  "rule_id": "100001",
  "src_ip": "192.168.0.121",
  "action_taken": "blocked",
  "message": "Blocked 192.168.0.121"
}
```

---

## 3. Wazuh ‚Üí Shuffle: la integraci√≥n por webhook

### 3.1 Configuraci√≥n en `ossec.conf`

![Configuraci√≥n integraci√≥n Wazuh-Shuffle](/images/blog/2025-11-17-respuesta-automatica-ssh-brute-force-soar/09_wazuh_ossec_conf.png)
_Caption: Integraci√≥n configurada con level 10 - solo alertas importantes_

```xml
<!-- Integration with Shuffle SOAR -->
<integration>
  <name>shuffle</name>
  <hook_url>http://192.168.0.123:3001/api/v1/hooks/webhook_17702e08-066f-4c9a-ae3a-d61f1622b9af</hook_url>
  <level>10</level>
  <alert_format>json</alert_format>
</integration>
```

**Ubicaci√≥n:** Dentro del archivo `/var/ossec/etc/ossec.conf` en el Wazuh Manager

**Clave:** `<level>10</level>` ‚Üí solo alertas importantes (SSH brute force y eventos cr√≠ticos).

### 3.2 El problema del `level`

En los primeros tests dej√© `level = 3` y recib√≠ **una avalancha** de eventos normales: sudo exitoso, sesiones PAM, logins normales. El sistema era inusable.

**Soluci√≥n:** Subir a `level = 10` filtr√≥ todo excepto los eventos realmente cr√≠ticos.

![Alertas SSH nivel 10](/images/blog/2025-11-17-respuesta-automatica-ssh-brute-force-soar/22_wazuh_ssh_alerts.png)
_Caption: Solo alertas SSH brute force (nivel 10) - sistema silencioso hasta que importa_

**Niveles de alerta en Wazuh:**

- 0-3: Info/Debug (sesiones normales, sudo exitoso)
- 4-7: Warning (algunos fallos de auth)
- 8-12: **Alertas importantes** (SSH brute force, m√∫ltiples fallos)
- 13-15: **Cr√≠tico** (rootkits, malware)

### 3.3 Verificaci√≥n de logs de integraci√≥n

Para confirmar que Wazuh env√≠a al webhook correcto:

```bash
docker exec -it single-node-wazuh.manager-1 bash
tail -f /var/ossec/logs/integrations.log
```

![Logs de integraci√≥n Wazuh](/images/blog/2025-11-17-respuesta-automatica-ssh-brute-force-soar/23_wazuh_integration_logs.png)
_Caption: Alertas enviadas exitosamente al webhook correcto (17702e08...)_

**Qu√© buscar:**

- Webhook correcto (`...17702e08...`)
- Sin errores HTTP
- Timestamps recientes

### 3.4 Troubleshooting: XML comentado incorrectamente

**El bug m√°s tonto:** Coment√© mal la integraci√≥n durante tests:

```xml
<!-- <integration>
  ...
</integration> --> -->
```

El doble cierre `--> -->` **romp√≠a el XML** y `integratord` no arrancaba.

**S√≠ntoma:** El servicio `wazuh-integratord` aparec√≠a como `not running...`

**Fix:**

```bash
# Verificar sintaxis
grep -A 7 "Integration with Shuffle" /var/ossec/etc/ossec.conf

# Reiniciar servicios
/var/ossec/bin/wazuh-control restart
/var/ossec/bin/wazuh-control status | grep integratord
```

> **Lesson Learned:** Cuando nada llega al webhook, valid√° lo obvio primero (XML, servicios corriendo, red).

---

## 4. El momento de la verdad: prueba end‚Äëto‚Äëend

### 4.1 Setup de observabilidad (3 terminales simult√°neas)

**Terminal 1 - Wazuh integration logs:**

```bash
docker exec -it single-node-wazuh.manager-1 bash
tail -f /var/ossec/logs/integrations.log
```

**Terminal 2 - iptables watch:**

```bash
watch -n 2 'sudo iptables -L INPUT -n -v | grep DROP'
```

**Terminal 3 - Shuffle UI:**  
Navegador con pesta√±a **Runs** abierta

### 4.2 Ejecutando el ataque de prueba

![Test SSH brute force](/images/blog/2025-11-17-respuesta-automatica-ssh-brute-force-soar/11_ssh_brute_force_test.png)
_Caption: 6 intentos SSH fallidos - dispara la regla 100001_

```bash
for i in {1..6}; do
  echo "Intento $i"
  ssh fake_$(date +%N)@192.168.0.121
  sleep 3
done
```

### 4.3 La cascada autom√°tica (‚âà15 segundos end-to-end)

1. **T+0s:** falla el intento SSH #6
2. **T+2s:** Wazuh genera alerta `rule_id = 100001` (SSH brute force)
3. **T+3s:** `integratord` env√≠a webhook a Shuffle
4. **T+5s:** Shuffle ejecuta workflow `Process_and_Block`
5. **T+8s:** API Flask aplica `iptables -I INPUT -s <IP> -j DROP`
6. **T+10s:** Nodo `Log_Result` registra "blocked"

![IP bloqueada en iptables](/images/blog/2025-11-17-respuesta-automatica-ssh-brute-force-soar/20_iptables_blocked_ip.png)
_Caption: IP 192.168.0.121 bloqueada autom√°ticamente_

```bash
sudo iptables -L INPUT -n | grep 192.168.0.121
# OUTPUT: DROP  all  --  192.168.0.121  0.0.0.0/0
```

### 4.4 Evidencia en Wazuh Dashboard

![Alerta SSH en Dashboard](/images/blog/2025-11-17-respuesta-automatica-ssh-brute-force-soar/12_wazuh_alert_dashboard.png)
_Caption: Alerta SSH brute force detectada (rule 2502, nivel 10)_

![Ejecuci√≥n en Shuffle](/images/blog/2025-11-17-respuesta-automatica-ssh-brute-force-soar/13_shuffle_wazuh_execution.png)
_Caption: Lista de ejecuciones en Shuffle_

![Payload completo](/images/blog/2025-11-17-respuesta-automatica-ssh-brute-force-soar/14_shuffle_wazuh_payload.png)
_Caption: Payload Wazuh con rule_id, timestamp y detalles del ataque_

**Lo que confirmamos:**

- ‚úÖ `rule_id`: "100001" (SSH brute force from ::1)
- ‚úÖ `src_ip` extra√≠da: "192.168.0.121"
- ‚úÖ `action_taken`: "blocked"
- ‚úÖ Response time: menos de 15 segundos

### 4.5 M√©tricas finales del laboratorio

| M√©trica                | Valor                |
| ---------------------- | -------------------- |
| **Response time**      | ~10‚Äì15 segundos      |
| **False positives**    | 0 (con level 10)     |
| **Block rate**         | 100%                 |
| **Eventos procesados** | ~500/d√≠a             |
| **Detection rate**     | 100% SSH brute force |

> **Note:** M√©tricas de laboratorio con 1 agente. En producci√≥n variar√°n seg√∫n volumen y latencia de red.

---

## 5. Lecciones aprendidas y pr√≥ximos pasos

### 5.1 Errores cr√≠ticos que encontr√©

**1. Shuffle vs. booleanos Python**

- **S√≠ntoma:** `name 'true' is not defined` en el nodo
- **Causa:** Evaluar JSON crudo como objeto Python
- **Soluci√≥n:** Acceso directo a campos (`"$exec.rule_id"`)
- **Tiempo perdido:** ~3 horas üòÖ

**2. XML mal comentado en ossec.conf**

- **S√≠ntoma:** `integratord not running...`
- **Causa:** `--> -->` doble cierre
- **Soluci√≥n:** Limpiar comentario y reiniciar Wazuh

**3. Level demasiado bajo (3)**

- **S√≠ntoma:** Avalancha de eventos (sudo, PAM sessions)
- **Soluci√≥n:** `level = 10` para filtrar a eventos cr√≠ticos

### 5.2 Lo que funcion√≥ sorprendentemente bien

‚úÖ **Arquitectura minimalista (3 nodos):** Menos fr√°gil que 6 nodos con condiciones  
‚úÖ **API Flask:** R√°pido de desarrollar y debuggear  
‚úÖ **systemd service:** Robusto, se reinicia solo ante fallos  
‚úÖ **Regex flexible:** Maneja m√∫ltiples formatos de IP en logs

### 5.3 Lo que viene: completando el Bloque 2

**Este post cubri√≥:** SSH brute force response (el workflow m√°s cr√≠tico)

**Lo que falta del Bloque 2 (pr√≥ximo post):**

1. **üîî Notificaciones autom√°ticas**
   - Slack/Discord/Email cuando se bloquea una IP
   - Alertas para eventos cr√≠ticos
   - Dashboard de notificaciones

2. **üìÅ File Integrity Monitoring (FIM) Response**
   - Detectar cambios en `/etc/passwd`, `/etc/shadow`
   - Snapshot autom√°tico de archivos cr√≠ticos
   - Alertas elevadas para modificaciones no autorizadas

3. **üÜï New Host Detection**
   - Workflow cuando nuevo agente se conecta
   - Verificaci√≥n autom√°tica de compliance
   - Notificaci√≥n al equipo SOC

4. **üîç Enriquecimiento b√°sico con AbuseIPDB**
   - Verificar reputaci√≥n de IP antes de bloquear
   - Agregar "reputation_score" al resultado
   - Evitar falsos positivos

**Duraci√≥n estimada del pr√≥ximo post:** 2-3 horas de implementaci√≥n + testing

> **Spoiler:** Con estos 4 componentes adicionales tenemos un SOAR completo que cubre los casos de uso m√°s comunes de un SOC peque√±o/mediano.

### 5.4 Mejoras futuras (Bloques 3+)

1. **Threat Intelligence (Bloque 3):** MISP + feeds + APIs externas
2. **ML Anomaly Detection (Bloque 4):** Isolation Forest para patrones no-rule-based
3. **Asset Discovery (Bloque 5):** Nmap automation engine
4. **Dashboard Grafana (Bloque 7):** M√©tricas SOC en tiempo real

### 5.5 C√≥mo reproducir este setup

**Requisitos:**

- Wazuh SIEM operativo ([ver post anterior](https://cobalto-sec.tech/blog/2025-11-12-de-cero-a-soar-integrando-wazuh-con-shuffle))
- Shuffle instalado y accesible
- VM Ubuntu 22.04+ con Python 3.10+
- Acceso sudo para iptables

**Tiempo estimado:** 2‚Äì3 horas (con troubleshooting)

**Repositorio GitHub:** _(pr√≥ximamente - estoy organizando el c√≥digo)_

---

## Conclusi√≥n: de reactivo a proactivo

**Antes:** Las alertas llegaban. Yo las le√≠a. **Yo** bloqueaba IPs. A mano. Uno por uno.

**Ahora:** El sistema **detecta ‚Üí verifica ‚Üí bloquea ‚Üí registra**. Solo. Autom√°ticamente. En menos de 15 segundos.

**La diferencia es escalabilidad.** Puedo estar durmiendo y el SOC sigue respondiendo a ataques SSH brute force. Puedo escalar a 100 hosts sin cambiar el workflow.

**Pr√≥ximo paso:** Completar el Bloque 2 con notificaciones, FIM response y enriquecimiento de contexto. Despu√©s, agregar **inteligencia** (threat intel + ML) para decidir _mejor_ a qui√©n bloquear, no solo _m√°s r√°pido_.

Por ahora, tengo un sistema que **funciona**. Detecta SSH brute force y lo bloquea autom√°ticamente. Y eso... ya es bastante poderoso. üî•

---

## Ap√©ndice: Comandos de referencia

**Verificar integraci√≥n Wazuh:**

```bash
docker exec -it single-node-wazuh.manager-1 bash
grep -A 7 "Integration with Shuffle" /var/ossec/etc/ossec.conf
tail -f /var/ossec/logs/integrations.log
```

**Watch de iptables:**

```bash
watch -n 2 'sudo iptables -L INPUT -n -v | grep DROP'
```

**Ataque controlado:**

```bash
for i in {1..6}; do
  echo "Intento $i"
  ssh fake_$(date +%N)@192.168.0.121
  sleep 3
done
```

**Verificar bloqueo:**

```bash
sudo iptables -L INPUT -n | grep 192.168.0.121
```

**Test del API:**

```bash
# Health check
curl http://localhost:5555/health

# Bloquear
curl -X POST http://localhost:5555/block \
  -H "Content-Type: application/json" \
  -d '{"ip": "1.2.3.4"}'

# Desbloquear
curl -X POST http://localhost:5555/unblock \
  -H "Content-Type: application/json" \
  -d '{"ip": "1.2.3.4"}'
```

---

**Posts relacionados:**

- [De Cero a SOAR: Integrando Wazuh con Shuffle](https://cobalto-sec.tech/blog/2025-11-12-de-cero-a-soar-integrando-wazuh-con-shuffle)
- [Pr√≥ximamente: Completando el Bloque 2 - Notificaciones y FIM Response]

---
