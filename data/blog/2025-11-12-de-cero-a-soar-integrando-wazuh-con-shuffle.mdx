---
title: 'De Cero a SOAR: Desplegando Shuffle y conect√°ndolo con Wazuh (Mi primera automatizaci√≥n real)'
date: '2025-11-12T00:00:00'
lastmod: '2025-11-12T00:00:00'
summary: 'De Wazuh solo a un SOAR operativo con Shuffle: arquitectura LXC en Proxmox, webhooks, errores reales y la primera alerta recibida en acci√≥n.'
tags:
  ['wazuh', 'shuffle', 'soar', 'siem', 'docker', 'proxmox', 'lab', 'tutorial', 'troubleshooting']
draft: false
authors: ['default']
images: []
---

## Introducci√≥n

Semana 1 cerr√≥ con Wazuh funcionando. Buen comienzo‚Ä¶ pero incompleto. Las alertas exist√≠an, s√≠, s√≥lo que **todo era manual**: abrir dashboard, leer evento, decidir si actuar, ejecutar comandos.

Mi objetivo para esta entrega fue claro: **agregar un SOAR** que reciba alertas autom√°ticamente y me permita orquestar respuestas sin tocar nada. La elecci√≥n fue **Shuffle**, por ser open source, simple de desplegar y con un enfoque muy pr√°ctico para webhooks y workflows.

Llegu√© con la expectativa ingenua de "plug & play en 2 horas". La realidad tuvo otros planes: redes, permisos y nombres de host jugando en mi contra. Igual lo saqu√© adelante, y aqu√≠ est√° el proceso completo (con errores y soluciones incluidas).

> **Note:** Este no es un tutorial perfecto. Es mi proceso real, con decisiones de arquitectura, problemas que me frenaron y lo que aprend√≠ en el camino.

## 1. Decisiones de arquitectura

Antes de tirar comandos, par√© a pensar **d√≥nde** hospedar Shuffle. Evalu√© tres caminos y descart√© dos.

### 1.1 Opciones evaluadas

**‚ùå Docker en Windows**

- Posible, pero con limitaciones de networking significativas
- Complejidad innecesaria para rutear entre contenedores y mi homelab
- Experiencia previa: m√°s dolores de cabeza que beneficios

**‚ùå VM completa en Proxmox**

- Funciona bien, pero es overkill para pruebas
- Requiere 2-4 GB de RAM m√≠nimo
- Arranques lentos (30-60 segundos)
- Desperdicio de recursos para este caso de uso

**‚úÖ LXC Container en Proxmox (privileged)**

- **Ligero:** arranque en <5 segundos
- **Aislado:** destruir/recrear en minutos
- **Acceso directo:** al Docker socket (necesario para Orborus)
- **Snapshots r√°pidos:** backup/restore instant√°neos

> **Tip:** Para labs iterativos, LXC privileged ofrece el mejor balance entre aislamiento y velocidad. Si algo se rompe, lo destru√≠s y volv√©s a levantar en minutos sin quemar 4 GB de RAM.

### 1.2 Configuraci√≥n final elegida

- **Plataforma:** Proxmox LXC (privileged)
- **IP est√°tica:** 192.168.0.123
- **Sistema base:** Ubuntu 24.04
- **Stack interno:** Docker + Docker Compose
- **Recursos:** 2 GB RAM, 10 GB disco

**¬øPor qu√© LXC y no VM?**  
Porque consume menos (arranqu√© con 512 MB de RAM, luego escal√© a 2 GB seg√∫n necesidad), es instant√°neo para crear/destruir, puedo mapear el Docker socket directamente, y es trivial de backupear/restaurar con snapshots de Proxmox.

> **Lesson Learned:** No todo proyecto necesita una VM completa. Si vas a orquestar con Docker, tener Docker _dentro_ de una VM es muchas veces una capa de abstracci√≥n innecesaria que solo suma complejidad.

## 2. Implementaci√≥n paso a paso

### 2.1 Creaci√≥n del LXC container

**En Proxmox Web UI:**

1. **Create CT** (bot√≥n superior derecho)
2. **General:**
   - CT ID: `102`
   - Hostname: `shuffle-soar`
   - **Unprivileged container:** ‚ùå desmarcar (necesitamos privileged)
3. **Template:**
   - Storage: local
   - Template: `ubuntu-24.04-standard`
4. **Disks:**
   - Storage: local-lvm
   - Disk size: `10 GB`
5. **CPU:**
   - Cores: `2`
6. **Memory:**
   - RAM: `2048 MB`
   - Swap: `512 MB`
7. **Network:**
   - Bridge: `vmbr0`
   - IPv4: **Static**
   - IPv4/CIDR: `192.168.0.123/24`
   - Gateway: `192.168.0.1`
   - IPv6: SLAAC (o dejar en blanco)

**¬øPor qu√© privileged?**  
Shuffle Orborus (el componente que ejecuta apps de Docker) necesita acceso al **Docker socket del host**. Sin privileged, aparecen errores de permisos y las aplicaciones no ejecutan. Es un trade-off conocido de seguridad vs funcionalidad en labs.

> **Warning:** En producci√≥n, evalu√° alternativas como Docker-in-Docker o sidecar containers. Para un lab de aprendizaje, privileged est√° OK.

### 2.2 Instalaci√≥n de Docker en el LXC

Arranc√° el LXC y ejecut√°:

```bash
# Actualizar sistema
apt update && apt upgrade -y

# Instalar Docker y herramientas
apt install -y docker.io docker-compose git curl

# Verificar instalaci√≥n
docker --version
# Docker version 24.0.7, build...

docker-compose --version
# docker-compose version 1.29.2, build...

# Iniciar y habilitar Docker
systemctl start docker
systemctl enable docker

# Verificar que Docker corre
docker ps
# CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
```

> **Note:** Us√© `docker.io` del repositorio de Ubuntu por velocidad. Si necesit√°s Docker CE (Community Edition) oficial, segu√≠ las [instrucciones de Docker](https://docs.docker.com/engine/install/ubuntu/).

### 2.3 Despliegue de Shuffle

**Clonar el repositorio:**

```bash
cd /opt
git clone https://github.com/Shuffle/Shuffle
cd Shuffle

# Verificar archivos
ls -la
# docker-compose.yml, .env.example, etc.
```

**Crear archivo de configuraci√≥n:**

Shuffle trae un `docker-compose.yml` ejemplo, pero necesit√© ajustarlo. Cre√© `docker-compose-working.yml`:

```yaml
version: '3.8'

services:
  frontend:
    image: ghcr.io/shuffle/shuffle-frontend:latest
    container_name: shuffle-frontend
    hostname: shuffle-frontend
    ports:
      - '3001:80'
      - '3443:443'
    environment:
      - BACKEND_HOSTNAME=shuffle-backend # ‚Üê CLAVE: nombre interno
      - OUTER_HOSTNAME=192.168.0.123 # ‚Üê IP para acceso LAN
    networks:
      - shuffle-network
    depends_on:
      - backend
    restart: unless-stopped

  backend:
    image: ghcr.io/shuffle/shuffle-backend:latest
    container_name: shuffle-backend
    hostname: shuffle-backend
    ports:
      - '5001:5001'
    environment:
      - SHUFFLE_APP_HOTLOAD_FOLDER=/shuffle-apps
      - SHUFFLE_FILE_LOCATION=/shuffle-files
      - SHUFFLE_OPENSEARCH_URL=http://shuffle-opensearch:9200
      - SHUFFLE_ELASTIC=true
      - ORG_ID=Shuffle
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - shuffle-apps:/shuffle-apps
      - shuffle-files:/shuffle-files
    networks:
      - shuffle-network
    depends_on:
      - opensearch
    restart: unless-stopped

  orborus:
    image: ghcr.io/shuffle/shuffle-orborus:latest
    container_name: shuffle-orborus
    hostname: shuffle-orborus
    environment:
      - SHUFFLE_APP_SDK_VERSION=1.2.0
      - SHUFFLE_WORKER_VERSION=latest
      - ORG_ID=Shuffle
      - ENVIRONMENT_NAME=Shuffle
      - BASE_URL=http://192.168.0.123:5001
      - SHUFFLE_BASE_IMAGE_NAME=frikky
      - SHUFFLE_BASE_IMAGE_REGISTRY=ghcr.io
      - SHUFFLE_BASE_IMAGE_TAG_SUFFIX="-1.2.0"
      - DOCKER_API_VERSION=1.40 # ‚Üê Comentar si hay problemas
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    networks:
      - shuffle-network
    restart: unless-stopped

  opensearch:
    image: opensearchproject/opensearch:2.11.0
    container_name: shuffle-opensearch
    hostname: shuffle-opensearch
    environment:
      - discovery.type=single-node
      - bootstrap.memory_lock=true
      - 'OPENSEARCH_JAVA_OPTS=-Xms512m -Xmx512m'
      - 'DISABLE_SECURITY_PLUGIN=true'
    ulimits:
      memlock:
        soft: -1
        hard: -1
    volumes:
      - opensearch-data:/usr/share/opensearch/data
    networks:
      - shuffle-network
    restart: unless-stopped

networks:
  shuffle-network:
    driver: bridge

volumes:
  shuffle-apps:
  shuffle-files:
  opensearch-data:
```

**Variables de entorno cr√≠ticas:**

- `BACKEND_HOSTNAME=shuffle-backend`: El frontend usa este nombre para llamar al backend **dentro de la red Docker**. Nunca pongas una IP externa ac√°.
- `OUTER_HOSTNAME=192.168.0.123`: Esta IP es para acceso desde tu LAN (browser, Wazuh).
- `SHUFFLE_OPENSEARCH_URL`: URL interna de OpenSearch.

**Levantar los servicios:**

```bash
docker-compose -f docker-compose-working.yml up -d

# Ver logs mientras arranca
docker-compose -f docker-compose-working.yml logs -f

# Verificar que todos est√°n UP
docker ps
# Deber√≠as ver: frontend, backend, orborus, opensearch
```

**Acceder al dashboard:**

Abr√≠ tu browser y and√° a:

```
http://192.168.0.123:3001
```

Primera vez te pedir√° crear usuario admin. Us√° credenciales seguras (guard√° en 1Password/Bitwarden).

## 3. Troubleshooting: lo que NO funcion√≥ al principio

### 3.1 Frontend cargaba‚Ä¶ pero quedaba pantalla negra

**S√≠ntomas:**

- Dashboard se ve, pero no carga workflows/executions
- Browser console muestra: `Failed to fetch` o timeout
- Logs de frontend muestran: `502 Bad Gateway`

**Error exacto en logs:**

```
2025/11/11 22:15:34 [error] 28#28: *1 connect() failed (110: Connection timed out)
while connecting to upstream, client: 192.168.0.1, server: _,
request: "GET /api/v1/checkusers HTTP/1.1",
upstream: "http://192.168.0.123:5001/api/v1/checkusers",
host: "192.168.0.123:3001"
```

**Causa ra√≠z:**  
El frontend intentaba conectarse al backend usando **la IP externa (192.168.0.123)** en lugar del **nombre interno de Docker (shuffle-backend)**. Desde la red del host esto funciona, pero desde la **red interna de Docker**, no hay ruta.

**Fix:**

```yaml
# ‚ùå INCORRECTO (lo que ten√≠a inicialmente)
environment:
  - BACKEND_HOSTNAME=192.168.0.123

# ‚úÖ CORRECTO (lo que funcion√≥)
environment:
  - BACKEND_HOSTNAME=shuffle-backend
```

Despu√©s de cambiar, hice:

```bash
docker-compose -f docker-compose-working.yml down
docker-compose -f docker-compose-working.yml up -d

# Limpiar cach√© del browser (Ctrl+Shift+R o modo inc√≥gnito)
```

> **Lesson Learned:** Dentro de Docker, **SIEMPRE us√° nombres de contenedor**, nunca IPs. Docker DNS resuelve autom√°ticamente los nombres dentro de la misma red. Te ahorra dolores de cabeza al reconfigurar o mover servicios.

### 3.2 Orborus no ejecutaba apps

**S√≠ntomas:**

- Workflows con apps (HTTP, Tools, etc.) no ejecutan
- Executions quedan en estado "Running" infinito
- Logs de Orborus muestran errores de Docker API

**Error exacto:**

```
Error response from daemon: client version 1.40 is too old.
Minimum supported API version is 1.44, please upgrade your client
to a newer version.
```

**Causa ra√≠z:**  
Incompatibilidad de **versi√≥n de Docker API** entre Orborus y el daemon del host.

**Soluci√≥n parcial (temporal):**

Coment√© la variable `DOCKER_API_VERSION` en `docker-compose-working.yml`:

```yaml
orborus:
  environment:
    # - DOCKER_API_VERSION=1.40  # ‚Üê Comentado
```

Con esto, Orborus dej√≥ de quejarse de la versi√≥n, pero segu√≠ viendo problemas intermitentes al ejecutar apps complejas.

**¬øPor qu√© "soluci√≥n parcial"?**  
Porque **Orborus no es cr√≠tico para mi objetivo inmediato**: recibir alertas de Wazuh v√≠a webhook. Los webhooks funcionan perfectamente sin Orborus.

**¬øCu√°ndo necesito Orborus?**  
Cuando quiera ejecutar **apps dentro de workflows** (enrichment con APIs, bloqueos activos, scraping, etc.). Eso lo voy a refinar en iteraciones futuras del lab.

> **Tip:** Si tu objetivo inmediato es **ingestar eventos y validar la integraci√≥n**, no te bloquees por problemas de Orborus. Dej√° ese ajuste fino para la siguiente fase. Prioriz√° tener el flujo b√°sico funcionando primero.

### 3.3 Browser cach√© enga√±oso

**Problema menor pero frustrante:**  
Despu√©s de arreglar `BACKEND_HOSTNAME`, el dashboard segu√≠a sin cargar. Me tom√≥ 10 minutos darme cuenta: **cach√© del browser**.

**Fix:**

- `Ctrl + Shift + R` (hard refresh)
- O abrir en **modo inc√≥gnito**
- O cambiar de browser

> **Tip de debugging:** Si cambias configs de Docker y "no funciona", prob√° primero en modo inc√≥gnito antes de volver a reconfigurar. El cach√© te puede hacer perder tiempo.

## 4. Integraci√≥n con Wazuh

Con Shuffle operativo, era momento de **cerrar el loop**: que Wazuh env√≠e sus alertas a Shuffle autom√°ticamente.

### 4.1 Crear Workflow con Webhook en Shuffle

**Paso a paso en el dashboard:**

1. **Workflows** (men√∫ izquierdo) ‚Üí **New Workflow**
2. **Name:** `Test-Wazuh-Connection`
3. **Description:** "Primer test de integraci√≥n Wazuh‚ÜíShuffle"
4. Arrastrar nodo **Webhook** al canvas
5. Click en el nodo Webhook ‚Üí **Show Execution Argument**
6. Copiar la **Webhook URL**, algo como:
   ```
   http://192.168.0.123:3001/api/v1/hooks/webhook_a1b2c3d4e5f6...
   ```
7. **Save workflow**

> **Note:** La URL del webhook incluye un token √∫nico. No la compartas p√∫blicamente ni la expongas fuera de tu LAN. Si la filtr√°s por error, pod√©s regenerarla borrando y recreando el nodo.

### 4.2 Configurar Wazuh para enviar alertas v√≠a webhook

**Desaf√≠o t√©cnico:**  
El contenedor de Wazuh **no incluye editores de texto** (ni nano, ni vim, ni vi). Opciones:

1. Instalar nano (`apt install nano`) - agrega complejidad innecesaria
2. Usar `sed` o `echo` para inyectar config - m√°s portable
3. Crear un `ossec.conf` custom y montarlo como volumen - overhead para un test

Opt√© por **sed inline**, que es r√°pido y no deja dependencias.

**Comandos:**

```bash
# Entrar al contenedor del Manager
docker exec -it single-node-wazuh.manager-1 bash

# Agregar bloque de integraci√≥n despu√©s del cierre de </cluster>
sed -i '/<\/cluster>/a\
\  <integration>\
    <name>shuffle</name>\
    <hook_url>http://192.168.0.123:3001/api/v1/hooks/webhook_XXXXX</hook_url>\
    <level>3</level>\
    <alert_format>json</alert_format>\
  </integration>' /var/ossec/etc/ossec.conf

# Verificar que qued√≥ bien (deber√≠a mostrar el bloque reci√©n agregado)
grep -A6 "shuffle" /var/ossec/etc/ossec.conf

# Output esperado:
#   <integration>
#     <name>shuffle</name>
#     <hook_url>http://192.168.0.123:3001/api/v1/hooks/webhook_XXXXX</hook_url>
#     <level>3</level>
#     <alert_format>json</alert_format>
#   </integration>

# Reiniciar Wazuh para aplicar cambios
/var/ossec/bin/wazuh-control restart

# Monitorear logs de integraci√≥n
tail -f /var/ossec/logs/integrations.log
```

**Par√°metros clave:**

- `<name>shuffle</name>`: Identificador interno (puede ser cualquier string)
- `<hook_url>`: La URL del webhook de Shuffle (¬°reemplaz√° `XXXXX`!)
- `<level>3</level>`: Enviar alertas de nivel 3+ (severity: low, medium, high, critical)
- `<alert_format>json</alert_format>`: Formato JSON (m√°s f√°cil de parsear en Shuffle)

> **Warning:** Cuid√° la **indentaci√≥n** en el `sed`. XML es sensible a espacios. Si copi√°s/peg√°s desde una terminal con encoding diferente, puede romper el archivo de config. Siempre verific√° con `grep` despu√©s.

### 4.3 Generar evento de prueba y validar

**Generar un SSH failed login:**

Desde tu PC/laptop, intent√° conectarte con credenciales incorrectas:

```bash
# Reemplaz√° por la IP de tu VM Ubuntu con agente Wazuh
ssh usuario_falso@192.168.0.121

# Ingresar password incorrecto 3 veces
# Wazuh detecta esto como "brute force attempt"
```

**Verificar en logs de Wazuh:**

```bash
tail -f /var/ossec/logs/integrations.log

# Output esperado:
# 2025-11-11 22:31:21 INFO: Sending alert to Shuffle
# /tmp/shuffle-1762900283-28084295.alert
# Alert sent successfully to webhook
```

**Verificar en Shuffle:**

1. Dashboard ‚Üí **Workflows** ‚Üí `Test-Wazuh-Connection`
2. Tab **Executions** (arriba a la derecha)
3. Deber√≠as ver una ejecuci√≥n nueva con status "Success"
4. Click en la ejecuci√≥n ‚Üí **Execution Argument** muestra el JSON:

```json
{
  "severity": 1,
  "pretext": "WAZUH Alert",
  "title": "sshd: authentication failed.",
  "rule_id": "5710",
  "agent_id": "001",
  "agent_name": "wazuh-agent-01",
  "timestamp": "2025-11-11T22:31:21.602+0000",
  "src_ip": "192.168.0.1",
  "id": "1762900281.771195"
}
```

**¬°Primera alerta autom√°tica recibida! üéâ**

> **Lesson Learned:** Teste√° con eventos simples primero (login fallido, sudo command) antes de construir workflows complejos. Valid√°s red, permisos y parsing en minutos, y si algo falla, sab√©s exactamente d√≥nde buscar.

## 5. Arquitectura final (actualizada)

As√≠ qued√≥ mi homelab despu√©s de agregar Shuffle:

```
Internet
    ‚Üì
Router: 192.168.0.1
    ‚Üì
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Red Local: 192.168.0.0/24
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    ‚îÇ
    ‚îú‚îÄ Proxmox Host: 192.168.0.115
    ‚îÇ  ‚îÇ
    ‚îÇ  ‚îú‚îÄ LXC 100: Wazuh Manager (192.168.0.120)
    ‚îÇ  ‚îÇ  ‚îî‚îÄ Docker Stack:
    ‚îÇ  ‚îÇ     ‚îú‚îÄ wazuh-manager (port 1514/udp, 1515/tcp)
    ‚îÇ  ‚îÇ     ‚îú‚îÄ wazuh-indexer (Elasticsearch)
    ‚îÇ  ‚îÇ     ‚îî‚îÄ wazuh-dashboard (port 443)
    ‚îÇ  ‚îÇ
    ‚îÇ  ‚îî‚îÄ LXC 102: Shuffle SOAR (192.168.0.123) ‚Üê NUEVO
    ‚îÇ     ‚îî‚îÄ Docker Stack:
    ‚îÇ        ‚îú‚îÄ shuffle-frontend (port 3001)
    ‚îÇ        ‚îú‚îÄ shuffle-backend (port 5001)
    ‚îÇ        ‚îú‚îÄ shuffle-opensearch (port 9200)
    ‚îÇ        ‚îî‚îÄ shuffle-orborus
    ‚îÇ
    ‚îú‚îÄ VM 1: wazuh-agent-01 (192.168.0.121)
    ‚îÇ  ‚îî‚îÄ Ubuntu 24.04 + Wazuh Agent + SSH
    ‚îÇ
    ‚îî‚îÄ VM 2: apache-server (192.168.0.122)
       ‚îî‚îÄ Ubuntu 24.04 + Wazuh Agent + Apache2

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
FLUJO DE DATOS (de evento a acci√≥n):
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

1. VM genera evento (ej: SSH failed login)
        ‚Üì
2. Wazuh Agent captura log y lo env√≠a al Manager
        ‚Üì (port 1514/udp)
3. Wazuh Manager procesa, normaliza y aplica reglas
        ‚Üì (rule match: level 3+)
4. Manager genera alerta y la env√≠a v√≠a HTTP POST
        ‚Üì (webhook URL)
5. Shuffle recibe la alerta en el Webhook
        ‚Üì
6. Workflow se ejecuta (acciones configuradas)
        ‚Üì
7. [Pr√≥ximas iteraciones: bloqueos, notificaciones, etc.]
```

> **Tip:** Documentar el flujo de datos me ayud√≥ a aislar problemas m√°s r√°pido. Si no llega al webhook ‚Üí falla en Wazuh o en red. Si llega pero no hay ejecuci√≥n ‚Üí revisar backend de Shuffle. Si ejecuta pero el resultado es vac√≠o ‚Üí revisar el workflow.

## 6. M√©tricas y resultados

**Tiempo de implementaci√≥n:**

- **Estimaci√≥n inicial:** 2 horas
- **Tiempo real:** ~3 horas (incluyendo troubleshooting)
- **Breakdown:**
  - Creaci√≥n de LXC + instalaci√≥n Docker: 20 min
  - Deploy de Shuffle: 30 min
  - Troubleshooting networking: 1.5 horas (!!)
  - Integraci√≥n con Wazuh: 30 min
  - Testing y validaci√≥n: 30 min

**Recursos utilizados:**

- **LXC Shuffle:** 2 GB RAM, 10 GB disco
- **CPU usage:** menos de 5% en idle, menos de 20% procesando alertas
- **Network:** ~100 KB/s durante picos de alertas
- **Disk I/O:** M√≠nimo (OpenSearch escribe logs localmente)

**Alertas procesadas durante testing:**

- **SSH failed logins:** 5 eventos
- **Sudo commands:** 3 eventos
- **Wazuh started:** 1 evento (√∫til para validar conectividad)

**Latencia end-to-end:**

- Evento generado ‚Üí Alerta en Shuffle: ** menos de 2 segundos**
- Consistente en todos los tests

> **Note:** Empec√© con la expectativa de "2 horas y listo". La realidad (con troubleshooting de networking) fueron ~3 horas. Pero el valor es enorme: de cero a un SOAR funcional recibiendo alertas reales en una tarde.

## 7. Lecciones aprendidas

### T√©cnicas

1. **LXC > VM para servicios Docker en homelab**  
   Menor overhead, arranque instant√°neo, mismo nivel de aislamiento para labs.

2. **Nombres de contenedor > IPs en Docker**  
   Docker DNS resuelve autom√°ticamente. Hace el stack portable y f√°cil de reconfigurar.

3. **Webhooks > APIs para integraciones simples**  
   Para casos de "evento ‚Üí acci√≥n", webhooks son m√°s directos que polling de APIs.

4. **`sed` es tu amigo cuando no hay editores**  
   Aprend√© los basics de `sed` para containers minimalistas. Ahorra tiempo.

5. **Orborus es opcional al principio**  
   Para validar el flujo de alertas, no necesit√°s que Orborus funcione perfectamente. Enfocate en el loop b√°sico primero.

### Arquitectura

1. **Separar componentes = mayor modularidad**  
   Wazuh en un LXC, Shuffle en otro. Puedo destruir uno sin afectar el otro.

2. **IP est√°tica es cr√≠tica para integraciones**  
   DHCP puede cambiar IPs y romper webhooks. Siempre est√°tico para servicios core.

3. **Privileged containers habilitan Docker-in-Docker**  
   Trade-off conocido: menos seguridad, m√°s flexibilidad. Para labs est√° OK.

4. **OpenSearch local > Elasticsearch cloud**  
   Para prototipos r√°pidos, tener todo local es m√°s simple y no genera costos.

### Troubleshooting

1. **Logs primero, siempre**  
   `docker-compose logs` te da el 80% de la info que necesit√°s para debuggear.

2. **Network issues = 90% de los problemas en Docker**  
   Cuando algo no funciona, empez√° por verificar: nombres DNS, rutas, firewalls.

3. **Browser cache puede enga√±ar**  
   Modo inc√≥gnito (Ctrl+Shift+N) o hard refresh (Ctrl+Shift+R) evita falsos negativos.

4. **`tail -f` > leer logs "muertos"**  
   Ver logs en tiempo real te permite correlacionar acciones con resultados instant√°neamente.

> **Lesson Learned:** Cuando algo falle, **nombr√° la hip√≥tesis** que est√°s probando antes de ejecutar el siguiente comando. Te obliga a dise√±ar el diagn√≥stico con intenci√≥n y reduc√≠s los "clicks al aire".

## 8. Pr√≥ximos pasos (teaser Semana 2)

Con las alertas llegando a Shuffle, ya puedo construir **acciones reales** en workflows. Los pr√≥ximos objetivos:

**1. Playbook de auto-bloqueo de IPs**  
SSH brute force ‚Üí detectar ‚Üí bloquear IP en firewall (iptables) ‚Üí notificar.

**2. Notificaciones contextualizadas a Slack**  
Enviar alertas a un canal de Slack con informaci√≥n enriquecida (IP, pa√≠s, etc.).

**3. Enriquecimiento con AbuseIPDB**  
Consultar reputaci√≥n de IPs atacantes y agregar contexto de threat intelligence.

**4. Dashboard de m√©tricas de respuesta**  
Visualizar: tiempo de respuesta, tipos de ataques bloqueados, IPs baneadas, etc.

**Meta de Semana 2:**  
Bajar el **MTTR** (Mean Time To Response) de ~5 minutos (manual) a ** menos de 10 segundos** (autom√°tico).

> **Tip:** Si vas a bloquear IPs autom√°ticamente, empez√° en **modo "audit"** (log only) y despu√©s pas√° a **mode "enforce"**. No quer√©s bloquearte a vos mismo durante la demo ;)

## 9. Recursos y referencias

**Documentaci√≥n oficial:**

- [Shuffle Docs](https://shuffler.io/docs) - Gu√≠as, ejemplos de workflows
- [Wazuh Integration Guide](https://documentation.wazuh.com/current/proof-of-concept-guide/integrate-external-tools.html) - Integraci√≥n con herramientas externas
- [Docker Compose](https://docs.docker.com/compose/) - Referencia completa

**Comunidad:**

- [Shuffle Discord](https://discord.gg/B2CBzUm) - Ayuda activa de la comunidad
- [Wazuh Slack](https://wazuh.com/community/join-us-on-slack/) - Soporte oficial

---

## Ap√©ndice: Comandos exactos (para copiar-pegar)

### Docker + Compose en LXC

```bash
apt update && apt upgrade -y
apt install -y docker.io docker-compose git curl

systemctl start docker
systemctl enable docker

docker --version
docker-compose --version
```

### Clonar y preparar Shuffle

```bash
cd /opt
git clone https://github.com/Shuffle/Shuffle
cd Shuffle

# Copiar ejemplo de docker-compose
cp docker-compose.yml docker-compose-working.yml

# Editar seg√∫n necesidad (ver secci√≥n 2.3)
nano docker-compose-working.yml
```

### Levantar Shuffle

```bash
docker-compose -f docker-compose-working.yml up -d

# Ver logs
docker-compose -f docker-compose-working.yml logs -f

# Verificar estado
docker ps
```

### Crear Workflow con Webhook en Shuffle

1. Dashboard ‚Üí **Workflows** ‚Üí **New Workflow**
2. Name: `Test-Wazuh-Connection`
3. Arrastrar **Webhook** al canvas
4. Click en Webhook ‚Üí **Show Execution Argument**
5. Copiar URL: `http://192.168.0.123:3001/api/v1/hooks/webhook_XXXXX`

### Integraci√≥n en Wazuh (sin editores)

```bash
# Entrar al contenedor
docker exec -it single-node-wazuh.manager-1 bash

# Agregar integraci√≥n con sed
sed -i '/<\/cluster>/a\
\  <integration>\
    <name>shuffle</name>\
    <hook_url>http://192.168.0.123:3001/api/v1/hooks/webhook_XXXXX</hook_url>\
    <level>3</level>\
    <alert_format>json</alert_format>\
  </integration>' /var/ossec/etc/ossec.conf

# Verificar config
grep -A6 "shuffle" /var/ossec/etc/ossec.conf

# Reiniciar Wazuh
/var/ossec/bin/wazuh-control restart

# Monitorear logs
tail -f /var/ossec/logs/integrations.log
```

### Evento de prueba

```bash
# Desde tu PC/laptop
ssh usuario_falso@192.168.0.121

# Fallar password 3 veces ‚Üí genera alerta en Wazuh ‚Üí llega a Shuffle
```

### Verificar en Shuffle

Dashboard ‚Üí Workflows ‚Üí Test-Wazuh-Connection ‚Üí **Executions** ‚Üí Ver √∫ltima ejecuci√≥n

---

**¬øPreguntas, comentarios, sugerencias?**  
Dej√° tu feedback en los comentarios. Si te sirvi√≥, compartilo con alguien que est√© armando un lab similar.

**Pr√≥ximo post:** "Playbook autom√°tico: de SSH brute force a IP bloqueada en menos de 10 segundos"
